; Animacion final de nivel. El sprite pasa y va borrando su rastro.
; version final


meta:
    ld hl, monster_truck_METAM
    ld (DS_SPRITESM), hl
    ld hl, monster_truck_META_attribM
    ld (DS_ATTRIBSM), hl
    ;ld a, 16          ;Hardcore inicial de adonde salia el Monster Truck al llegar a la meta
    ;ld (DS_COORD_XM), a
    ;ld a, 10
    ;ld (DS_COORD_YM), a

    ld a, (DS_COORD_X)      ; Ahora el Monster Truck saldra de adonde este el personaje
    ld (DS_COORD_XM), a
    ld a,(DS_COORD_Y)
    ld (DS_COORD_YM), a

    ld a, 7 ;antes eran 6
    ld (DS_WIDTHM), a
    ld a, 4
    ld (DS_HEIGHTM), a
    xor a
    ld (DS_NUMSPRM), a

loopRecorridoFinal: 
    call DrawSprite_MxN_LD
    ld a, (DS_COORD_XM)
    INC A
    ld (DS_COORD_XM), a
    CP 26
    .loop 20
        halt
    .endl        
    jr nz, loopRecorridoFinal
    
    ld a, (DM_NIVEL)
    INC a
    ld (DM_NIVEL),a

    .loop 100
        halt
    .endl   

    ld a,(FrutaUvasVar)    
    cp 9 ; comprobamos si hemos cogido las uvas del flash
    jp nz,loopRecorridoFinalFinal
    ; Si llegamos aqui tenemos que reinicializar los atributos de las rocas
    ld hl,rocasAtributos
    .loop 28
        ld a,(hl)
        sub a,128
        ld (hl),a
        inc hl
    .endl 

loopRecorridoFinalFinal:
    xor a
    ld (FrutaUvasVar),a ; Inicializo a 0 las frutas especiales
    jp inicioNivel     

 
; Variables que usaremos como parámetros
DS_SPRITESM  DEFW   0
DS_ATTRIBSM  DEFW   0
DS_COORD_XM  DEFB   0
DS_COORD_YM  DEFB   0
DS_NUMSPRM   DEFB   0
DS_WIDTHM    DEFB   0
DS_HEIGHTM   DEFB   0

;-------------------------------------------------------------
; DrawSprite_MxN_LD:
; Imprime un sprite de MxN pixeles con o sin atributos.
; Maximo, 16x15 / 15x16 bloques de ancho x alto caracteres.
;
; Entrada (paso por parametros en memoria):
; Direccion   Parametro
; Direccion        Parametro
; (DS_SPRITES)      Direccion de la tabla de Sprites
; (DS_ATTRIBS)      Direccion de la tabla de Atribs  (0=no atributos)
; (DS_COORD_X)      Coordenada X en baja resolucion
; (DS_COORD_Y)      Coordenada Y en baja resolucion
; (DS_NUMSPR)       Numero de sprite a dibujar (0-N)
; (DS_WIDTH)        Ancho del sprite
; (DS_HEIGHT)       Alto del sprite
;-------------------------------------------------------------
DrawSprite_MxN_LD:
 
    ;;; Calcular posicion origen (array sprites) en HL como:
    ;;;     direccion = base_sprites + (NUM_SPRITE*ANCHO*ALTO)
 
    ;;;; Multiplicamos ancho por alto (en bloques)
    ld a, (DS_WIDTHM)
    ld c, a
    ld a, (DS_HEIGHTM)
    rlca               ; Multiplicamos por 8, necesitamos
    rlca               ; la altura en pixeles (FILAS*8)
    rlca               ; Y la guardamos porque la necesitaremos:
    ld (drawsp_height), a
 
    ;;; Multiplicamos Ancho_bloques * Alto_pixeles:
    ld b, a
    xor a              ; A = 0
drawsp_mul1:
    add a, c           ; A = A + C   (B veces)  = B*C
    djnz drawsp_mul1   ; B veces -> A = A*C = Ancho * Alto
                        ; Ahora A = Ancho*Alto (maximo 255!!!)
 
    ;;; Multiplicamos DS_NUMSPR por (Ancho_bloques*Alto_pixeles)
    ld b, a            ; Repetimos Ancho * Alto veces
    ld hl, 0
    ld d, h            ; HL = 0
    ld a, (DS_NUMSPRM)
    ld e, a            ; DE = DS_NUMSPR
drawsp_mul2:
    add hl, de         ; HL = HL+DS_NUMSPR
    djnz drawsp_mul2   ; Sumamos HL+DE B veces = DS_NUMSPR*B
 
                        ; guardamos el valor de ancho*alto_pixeles*NUMSPR
    ld (drawsp_width_by_height), hl
 
    ;;; Calculamos direccion origen copia en el sprite
    ld bc, (DS_SPRITESM)
    add hl, bc         ; HL = BC + HL = DS_SPRITES + (DS_NUMSPR*ANCHO*ALTO)
                       ; HL contiene la direccion de inicio en el sprite
 
    ;;; Calculamos las coordenadas destino de pantalla en DE:
 
    ; ld bc, (DS_COORD_XM)     ; B = Y,  C = X originariamente codifica la posicion con un registro de 16 bits
    ld a, (DS_COORD_YM)     
    ld b,a                  ; B = Y
    ld a, (DS_COORD_XM)     ; C = X,    eje x
    ld c,a

    ld a, b
    and $18
    add a, $40
    ld d, a
    ld a, b
    and 7
    rrca
    rrca
    rrca
    add a, c
    ld e, a
    push de            ; Lo guardamos para luego, lo usaremos para
                       ; calcular la direccion del atributo
    ex de, hl          ; Intercambiamos DE y HL (DE=origen, HL=destino)
 
 
    ;;; Bucle de impresión vertical
                        ; Recogemos de nuevo la altura en pixeles
    ld a, (drawsp_height)
    ld b, a            ; Contador del bucle exterior del bucle
 
drawsp_yloop:
    ld c, b            ; Nos guardamos el contador
    
    ;;; Bucle de impresion horizontal
    ld a, (DS_WIDTHM)
    ld b, a
 
    push hl            ; Guardamos en pila inicio de scanline
                        ; para poder volver a el luego
drawsp_xloop:
    ld a, (de)         ; Leemos dato del sprite
    ld (hl), a         ; Copiamos dato a pantalla
    inc de             ; Incrementar puntero en sprite
    inc l              ; Incrementar puntero en pantalla
    djnz drawsp_xloop
    pop hl             ; Recuperamos de pila inicio de scanline
 
    ;;; Avanzamos al siguiente scanline de pantalla
    inc h
    ld a, h
    and 7
    jr nz, drawspNM_nofix
    ld a, l
    add a, 32
    ld l, a
    jr c, drawspNM_nofix
    ld a, h
    sub 8
    ld h, a
drawspNM_nofix:
 
    ld b, c
    djnz drawsp_yloop  ; Repetimos "alto_en_pixeles" veces
 
    ;;; Aqui hemos dibujado todo el sprite, vamos a los attributos
 
    pop bc             ; Recuperamos el offset del primer scanline
 
    ;;; Considerar el dibujado de atributos (Si DS_ATTRIBS=0 -> ret)
    ld  a,[DS_ATTRIBSM+1]     ; para obtener la parte alta de la direccion
    or  a                    ; para comprobar si es 0
    ret z                    ; Si H = 0, volver (no dibujar atributos)
 
    ;;; Calcular posicion destino en area de atributos en DE.
    ld a, b            ; Codigo de Get_Attr_Offset_From_Image
    rrca               ; Obtenemos dir de atributo a partir de
    rrca               ; dir de zona de imagen.
    rrca               ; Nos evita volver a obtener X e Y
    and 3              ; y hacer el calculo completo de la
    or $58             ; direccion en zona de atributos
    ld d, a
    ld e, c            ; DE tiene el offset del attr de HL
    push de            ; Guardamos una copia
 
    ; Recuperamos el valor de ancho_caracteres * alto_en_pixeles * NUMSPR
    ; para ahorrarnos repetir otra vez dos multiplicaciones:
    ld hl, (drawsp_width_by_height)
 
    ;;; HL = ANCHO_BLOQUES*ALTO_PIXELES*NUMSPR
    ;;; El Alto lo necesitamos en BLOQUES, no en píxeles-> dividir /8
    srl h     ; Desplazamos H a la derecha
    rr l      ; Rotamos L a la derecha introduciendo CF
    srl h     ;
    rr l      ;
    srl h     ;
    rr l      ; Resultado : HL = HL >> 3 = HL / 8
 
    ;;;; HL = ANCHO_BLOQUES*ALTO_BLOQUES*NUMSPR
    ld c, l
    ld b, h
    ld hl, (DS_ATTRIBSM)
    add hl, bc         ; HL = Base_Atributos + (DS_NUMSPR*ALTO*ANCHO)
 
    pop de             ; Recuperamos direccion destino
 
    ld a, (DS_HEIGHTM)
    ld b, a
 
    ;;; Bucle impresion vertical de atributos
drawsp_attyloop:
    ld c, b
 
    push de            ; Guardamos inicio de linea de atributos
    ld a, (DS_WIDTHM)
    ld b, a
 
    ;;; Bucle impresion horizontal de atributos
drawsp_attxloop:
    ld a, (hl)         ; Leer atributo del sprite
    inc hl
    ld (de), a         ; Escribir atributo
    inc e
    djnz  drawsp_attxloop
 
    pop de             ; Recuperamos inicio de linea de atributos
 
    ;;; Avance diferencial a la siguiente linea de atributos
    ld a, e
    add a, 32
    ld e, a
    jr nc, drawsp_attrab_noinc
    inc d
drawsp_attrab_noinc:
 
    ld b, c
    djnz drawsp_attyloop
 
    ret
 
drawsp_height          DB 0
drawsp_width_by_height DW 0

   
